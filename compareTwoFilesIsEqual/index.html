<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .wrapper {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
      }

      .file1-box,
      .file2-box {
        width: 30%;
        min-height: 400px;
        box-sizing: border-box;
        font-size: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 30px;
        border: 10px dashed;
      }

      .file1-box {
        border-color: rgb(255, 255, 27);
      }

      .file2-box {
        border-color: yellowgreen;
      }

      button,
      #res {
        font-size: 30px;
        width: 80%;
        min-height: 50px;
        margin: 10px 10%;
      }

      .error {
        color: red;
      }
      .success {
        color: green;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <div class="file file1-box">请拖入第一个文件</div>
      <div class="file file2-box">请拖入第二个文件</div>
    </div>

    <button>比较两个文件</button>

    <div id="res"></div>

    <script>
      const fileBoxes = document.querySelectorAll('.file')
      const btn = document.querySelector('button')
      btn.addEventListener('click', compare, false)
      // 输出信息的盒子
      const resBox = document.querySelector('#res')

      // 为文件盒子绑定拖入文件功能
      for (const fileBox of fileBoxes) {
        fileBox.addEventListener(
          'dragover',
          function (e) {
            e.stopPropagation()
            e.preventDefault()
          },
          false
        )

        fileBox.addEventListener(
          'drop',
          function (e) {
            e.stopPropagation()
            e.preventDefault()

            const file = e.dataTransfer.files[0]
            console.log(file)

            fileBox.file = file
            fileBox.innerHTML = file.name

            // 通过数组缓存读取文件
            const frArrBuffer = new FileReader()

            frArrBuffer.onload = function () {
              console.log(this.result)

              fileBox.arrayBuffer = this.result
              fileBox.innerHTML += '<br>' + 'size：' + this.result.byteLength + '字节'
            }

            // 通过字符读取文件
            frArrBuffer.readAsArrayBuffer(file)
            const frString = new FileReader()
            frString.onload = function () {
              fileBox.string = this.result
            }
            frString.readAsText(file)

            // 清空输出的消息
            resBox.innerHTML = ''
          },
          false
        )
      }

      //字符串转字符串ArrayBuffer
      function strToArrBuffer(s) {
        return new Promise((resolve) => {
          var b = new Blob([s], { type: 'text/plain' })
          var r = new FileReader()
          r.readAsArrayBuffer(b)
          r.onload = function () {
            resolve(this.result)
          }
        })
      }

      // 找到当前字节，对应的字符
      function findChar(arr, n, string) {
        // for (let i = 1; i < arr.length; i++) {
        //   if (n > arr[i - 1] && (arr[i + 1] === undefined || n < arr[i + 1])) {
        //     // 由于byteMapCharTwo数组为了方便计算前缀和，所以下标从1开始；而string下标还是从0开始，所以需要减1
        //     return `对应文件的第 ${i} 个字符：${string[i - 1]}`
        //   }
        // }

        // 从后往前找，找第到第一个字节比他小的后一个，就是对应的字符的字节
        for (let i = arr.length - 1; i > 0; i--) {
          if (arr[i] < n) {
            // 由于byteMapCharTwo数组为了方便计算前缀和，所以下标从1开始；而string下标还是从0开始，所以需要减1
            i += 1
            return `对应文件的第 ${i} 个字符：${string[i - 1]}`
          }
        }

        return '"[System Message:对应字符不存在]"'
      }

      // 比较两个文件的不同
      async function compare() {
        const file1Box = document.querySelector('.file1-box')
        const file2Box = document.querySelector('.file2-box')
        // 读取文件的缓存
        const fileBufferOne = file1Box.arrayBuffer
        const fileBufferTwo = file2Box.arrayBuffer

        // 读取文件的字符
        const fileStringOne = file1Box.string
        const fileStringTwo = file2Box.string

        // 文件字节映射到字符的数组
        const byteMapCharOne = [0]
        const byteMapCharTwo = [0]

        // 读取文件的字节
        const fileByteArrOne = new Uint8Array(fileBufferOne)
        const fileByteArrTwo = new Uint8Array(fileBufferTwo)

        // 显示文件不相同的错误信息
        function showError(byte) {
          resBox.innerHTML = `两个文件在第 ${byte} 个字节处发生不同<br>第一个文件的第 ${byte} 字节为：${fileByteArrOne[idx] ?? '"[System Message:不存在]"'}，\t ${findChar(byteMapCharOne, byte, fileStringOne)}<br>第二个文件的第 ${byte} 字节为：${
            fileByteArrTwo[idx] ?? '"[System Message:不存在]"'
          }，\t ${findChar(byteMapCharTwo, byte, fileStringTwo)}`
          resBox.className = 'error'
        }

        // 创建字节映射字符的关系数组
        for (const char of fileStringOne) {
          const res = await strToArrBuffer(char)
          byteMapCharOne.push(res.byteLength + byteMapCharOne[byteMapCharOne.length - 1])
        }
        for (const char of fileStringTwo) {
          const res = await strToArrBuffer(char)
          byteMapCharTwo.push(res.byteLength + byteMapCharTwo[byteMapCharTwo.length - 1])
        }

        console.log(byteMapCharOne, byteMapCharTwo)

        // 字节序号，从0开始
        let idx = 0

        // 查找两个文件中对应字符是否一样
        while (idx < fileByteArrOne.length && idx < fileByteArrTwo.length) {
          if (fileByteArrOne[idx] !== fileByteArrTwo[idx]) {
            showError(idx + 1)
            return
          }
          idx++
        }

        // 如果两个文件字节大小不一样
        if (idx < fileByteArrOne.length) {
          showError(fileByteArrTwo.length + 1)
        } else if (idx < fileByteArrTwo.length) {
          showError(fileByteArrOne.length + 1)
        } else {
          // 两个文件完全一样
          resBox.innerHTML = `两个文件字节完全相同！`
          resBox.className = 'success'
        }
      }
    </script>
  </body>
</html>
