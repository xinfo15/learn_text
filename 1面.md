### 自我介绍

### 项目问题

### 前端是如何做的优化

缓存、懒加载、防抖、节流



### sql题：如何查询在一个时间段之内的数据，并且按时间降序排列

当时忘记了sql操作时间的函数，就只是简单的口述了一下大概的流程，不同的数据库系统对于时间的操作函数也是不同的，下面列一个mysql的

加入查找一个最近一个月的数据

`select * from table where time > date_sub(date(), interval 1 month) order by time desc`



### 用过那些display的属性，现在有一个盒子，盒子里有两个块级的盒子，怎么让两个到同一行

给父盒子设置一个display: flex属性



### 跨域有了解吗

跨域指两个地址的协议、域名、端口其中有任何一个不相同，就是跨域



### 如何解决跨域

使用cors，cors是浏览器对于跨域请求的一种解决方案，可以在后端的响应头中配置对应的响应头，Access-Control-Allow-Origin响应头，配置允许跨域请求的地址，前端如果要在跨域请求中携带cookie，需要在ajax中配置对象的withCredential

使用JSONP

这个没想到：可以在本地架设一个服务器，我们请求这台本地服务器，然后利用本地服务器向后端发送代码，因为跨域是浏览器的限制，所以在本地服务器中请求不会受到跨域的影响，webpack里配置的proxy其实就是利用的这个，我们也称为本地代理



### 虚拟DOM相比真实DOM有什么优势

因为对真实DOM的操作的开销十分大，而虚拟DOM是将真实DOM抽象成javascript的对象，把对DOM的操作都集中到了这些js对象上，所以操作速度会更加的快，后续修改DOM会根据虚拟DOM的diff算法，进行差异比较，避免了无用的消耗，从而提升速度



### 用过nodejs吗，它适合用来做大数据量请求的处理吗

我当时想了想，回答的是可以，因为当时脑袋一想，js的异步任务是当任务产生结果后，加入任务队列，等待执行，我心想这个大量数据的任务就会在其他线程被计算出结果，然后被丢到任务队列，等待主线程的执行并返回

但总感觉回答的不对，自己还是没有太明白



### 输入url后发生了什么

浏览器输入url，根据url地址判断是否有强缓存机制存在

dns解析，将url解析为ip地址，dns查找顺序为 浏览器缓存->主机缓存->host文件->远程dns服务器，如果我们启用了CDN服务，则会利用CDN专属的DNS服务器，为我们分配一个负载均很服务器，随后会向负载均衡服务器请求，负载均衡服务器会根据缓存服务器的情况，如服务器距离，服务器负载情况，请求的地址等信息，返回一个最合适的缓存服务器ip地址，供我们使用

服务器收到请求后，会判断是否存在协商缓存机制，如果协商缓存存在且有效，则返回304状态码，告诉浏览器使用缓存，否则后台会正常处理请求，并返回数据

浏览器接收到响应后，就会根据html文件和css文件构建对应的DOM树和CSS规则树，在html解析过程中，如果遇到js文件，则会暂停解析，等待js文件下载并执行完成，在DOM树和CSS树构建完成之后，便会将它们合并，构建出一棵渲染树，然后根据一定规则对元素进行布局，这个过程叫重排，也叫文档回流，之后就是绘制对应的元素，将所有绘制指令交由GPU，最后GPU渲染，绘制到屏幕上



### 事件循环的理解

js拥有事件的原因主要因为js是单线程的，js没有办法同时处理多个任务，为了不让线程阻塞，就需要异步任务来缓解这个问题，有两个重要的概念，执行栈和任务队列，执行栈中存储的就是同步的任务，是按顺序执行的，而任务队列，则是由一些任务函数或者浏览器的一些事件产生的，比如setTimeout、Promise、事件监听的函数等等，这些任务不是同步执行的，而是将任务推入任务队列中，任务队列有两种类型，一种是宏任务队列，一种是微任务队列，setTimeout产生的就是宏任务，Promise产生的就是微任务，每一轮事件循环的开始，会从宏任务队列中弹出一个任务，然后执行，宏任务执行完之后，会执行微任务队列中的所有任务，包括在这些任务执行过程中产生的微任务，最后本轮事件循环结束之前，会进行ui界面的渲染



### Promise的三种状态

Pendding等待、Fulfilled完成、rejected拒绝



### HTTP请求中GET和POST的区别

get请求的参数是直接附带在url后面的，发送get请求只会产生一个数据包

post请求参数是在请求体重，发送post请求会产生两个数据包，第一个是先发送请求头，发送成功后会收到100的响应码，然后继续发送请求体



### v-if和v-show的区别

v-if渲染是惰性的，如果初始化时条件为false，直接就不会渲染元素，只有当条件为true时才会对元素进行渲染，不断切换条件会导致元素不断被删除和创建，有一定性能消耗

v-show都会渲染，只是当条件为false时，会为元素添加display: none的样式



### Vue中computed和watch的区别

computed主要就是用来管理多个依赖，当一个表达式需要使用到多个依赖，并且有稍微复杂的计算，就可以使用computed

computed有缓存机制，不能在computed中执行异步操作，因为computed需要在同步代码中返回计算属性的结果

watch主要就是用来监听属性的改变

watch没有缓存机制，数据都是实时计算，但是watch中可以执行异步操作



### 算法：最长公共前缀

给定一个字符串数组，求这个字符串数组的最长公共前缀

比如['1234','12567','1289']的最长公共前缀是12

创建前缀树来存储这所有的字符，之后遍历这个前缀树，如果子节点的个数大于2，说明此处开始不同，则返回前面所有的字符组成的数组

